# 7 Programming by Examples

## 7.1 Problem Definition

如§1.3所述，程序合成的问题在很大程度上是由它的三个主要组成部分的选择来定义的: **意图规范、程序空间和搜索算法**。在处理一个新问题时，我们通常可以控制算法的选择，并且在一定程度上控制程序空间。然而，**特定的规范类型通常是现实问题的基本部分**。由于可用的规范种类自然地限制了其他两个问题组件的可用选择，因此意图规范的限制激发了合成的子领域的大多数创新也就不足为奇了。子领域实例编程(PBE)就是这样一个例子。

在PBE中，综合问题由输入-输出示例(或者，更一般地，输入-输出约束)给出。它们指定所需程序对其有效输入子集的行为。在最简单的PBE场景中，规范定义了程序的输出; 在更复杂的情况下，它为输出指定一些属性或约束，而不是它们的精确值。由于示例便于用户指定问题，因此通常首选这些示例，但足够简单的输出约束也可以用于相同的目的。

输入-输出示例展示了几个惟一的特性，这些特性将PBE子领域与程序合成的其余部分区分开来。

**Ease of use:** 示例非常容易提供、解释和验证(与其他广泛使用的规范类型，如逻辑公式和断言相反)。这使它们成为非编程应用程序领域(如Excel中的数据争论或直接图形操作)的理想规范类型。

**Ambiguity:** 示例是不规范的(under-specification): 大多数时候，存在多个与给定示例集一致的程序。此外，在典型的现实生活语言中，一致程序的空间要么是无限的，要么是非常大的(例如，在数据争论域中高达10的20次方个)。问题规范中固有的**模糊性**构成了PBE中的一个额外挑战:我们不仅需要找到与规范一致的程序，还需要找到预期的程序(或语义上相同的程序)。

我们将重点关注用于处理PBE挑战的最流行的方法:(a)发现一致的程序，(b)处理大量一致的候选程序，(c)消除用户意图的歧义，以选择单个候选程序。

## 7.2 Version Space Algebra

如果合成算法的目标是在基于实例的规范中满足底层用户的意图(而不是寻找与之一致的任何单个程序)，那么它必须以某种方式**处理大量模棱两可的候选程序**。解决这个问题的一个常用工具是使用一种称为**版本空间代数**(VSA)的数据结构。<u>它允许在多项式空间(polynomial space)中表示潜在的指数程序集，并在多项式时间(polynomial time)内对这些集执行各种操作。</u>

![image-20210509155639536](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20210509155639536.png)

直观地说，VSA是DAG(有向无环图)，其中每个节点代表一组程序。叶节点包含程序的显式枚举; 它们由两个可能的VSA构造函数节点组成更大的集合。

**Union nodes U**表示组成它们的VSA的集合并集。

**Join nodes F><**表示它们的组成VSA的交叉积，并使用一个关联的操作符F应用于来自交叉积的所有参数程序组合。

还可以将VSA解释为其原始DSL L的一个子语言。如果我们把每个VSA叶节点和一个新的终结符关联起来，把每个构造函数节点和一个新的非终结符关联起来，我们就得到了一个上下文无关的语法L' ⊂ L，其中 连接节点对应操作员调用，联合节点对应交替：

![image-20210519173509994](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20210519173509994.png)

这个DSL包含两个非终结符N和P，两个终结符k和s，并引用三个操作ConstantString、Substring和AbsolutePosition。在这个DSL中，每个以N为根的程序都输出一个字符串——一个常量字符串s或由两个位置P定义的给定输入的子字符串。每个位置依次由一个整数k定义，它表示字符串中的绝对位置，如果k≥0，则从左边计算;  如果k < 0，则从右边计算。

![image-20210519174924868](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20210519174924868.png)

![image-20210519174826110](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20210519174826110.png)

VSA的关键特性是它们能够**在多项式空间(polynomial space)中编码指数程序集( encode exponential sets of programs)**。他们通过在程序子表达式之间提供两种共享来实现这一点。一个是由连接节点提供的，它对其子表达式集的交叉积进行编码。另一个是由VSA的DAG结构提供的，它允许通过DAG中的不同路径引用同一VSA节点的程序集共享子表达式。

VSA的另一个强大特性是**能够快速地对其执行各种集论操作**。这些操作通常是在VSA结构上归纳定义的。因此，它们的运行时间与VSA中节点的数量成正比，而不是它所代表的程序的数量(通常是指数级的)。在这个概述中，我们简单地列出了它们的列表:

​	**交集	|	聚类	|	排序	|	投影、过滤**

![image-20210519173425246](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20210519173425246.png)

读后问题

VSA的有向无环图具体是什么样的？如果有具体的例子来说明就更好了

VSA具体是如何对程序集进行各种操作的？还要再看看

## 7.3 Deduction-Based Techniques

**基于演绎的技术**

虽然前面讨论的任何合成算法都可以应用于PBE问题，但某些专门的算法通常表现得更好。**它们基于演绎搜索的思想: 将给定的例子自上而下地通过语法推进。**它直观地**应用分治原理将给定的合成问题简化为同类的更小的子问题。**子问题的选择及其结果的组合取决于算法。在过去的十年中，两种基于演绎的技术已经发展起来。一种是Flash Fill和随后的PROSE框架，它使用了DSL运算符的逆语义(Inverse Semantics)。另一种，由MYTH和SYNQUID系统推广，使用类型理论解释(type-theoretic interpretation)的PBE问题。

### 7.3.1 Inverse Semantics

在这种方法中，示例φ通过语法自上而下地从表达式传播到其子表达式。换句话说，**把程序分解到几个更简单的子问题，得到关于子表达式的新规范φ1和φ2。**它们的构造方式确保具有这些子表达式的任何程序F(E1, E2)都满足φ。

子表达式规范的构造依赖于所需程序中请求的顶级操作符F。本质上，我们需要倒转F: 如果一个程序F(E1, E2)在一个输入σ上输出y，那么E1和E2在相同的输入上应该输出什么? 回答这个问题为我们提供了E1和E2的必要规格，以确保整个程序满足φ。

在实践中，为语法中的每个运算符使用完全逆语义可能会造成计算开销过大。大多数实际的运算符都没有一个简单的封闭式的逆(a simple closed-form inverse)。**为了找到必要的子表达式规格，我们可能需要搜索对应子表达式的整个上域，这通常不是无穷就是太大。**例如，考虑一个关于给定输出列表'的列表处理操作符Filter(λx→Π， L)的逆语义。它必须找到所有的列表L和谓词Π，以便使用Π对L进行过滤得到'。对于符号L和Π下面的任何非平凡语法，这种可能的输入的数量是无限的。

为了缓解这种情况，该方法使用了三个关键理念:

**Witness function:** 逆语义的推广。通过使用一些启发式方法只选择可能的输入*likely inputs*，它返回生成φ中输出的可能输入的子集*subset*。例如，在上面的Filter场景中，它可能会忽略大型输入列表L。

**Constraints:** 概括例子的不完全规范under-specification。它描述了所需程序输出的某些属性，而不是提供整个输出值(如示例7.3)。在Filter场景中，L的一个必要规范是“its output should contain *L* as a sub-list”。当然，L下面的operators的见证函数必须能够处理这样的规范。

**Case split:** 逆语义的逐参数分解。我们不是同时构造所有子表达式规范(例如必要的输入)，而是一次构造一个。每个算子的每个参数Ei都有一个对应的见证函数，该见证函数为该参数子表达式构造了一个必要的规范φi。然后循环地学习一个与描述相一致的子程序集合。这个集合根据它的程序在φi的输入上的输出被分割成子集。After that, the search considers each branch of the case split independently, **under the assumption that the desired subexpression Ei evaluates to the corresponding output.** 其他参数的所有后续见证函数都考虑到这一假设，构建更小、更简单的必要规范。



整个算法依赖于设计者提供的***witness function***来通过DSL操作符反向传播示例。传统上，它也使用VSA作为其学习程序集的底层表示。它不一定是一个VSA，但这种数据结构特别适合，因为它支持两个重要操作的有效实现:

**Intersection of program sets:程序集的交集:** 从n个与个别例子相一致的程序集中构造出一个与多个例子φ1∧...∧φn相一致的程序集。
**Clustering of program sets程序集聚类:** 在学习了DSL操作符的单个参数的程序集后，执行大小写分割。
**(Optional) Ranking(可选)排序:** 根据某个排序函数h学习出最优的程序，动态地从学习到的程序集中选取最优的参数程序。

### 7.3.2 Type-Based Perspective

基于类型的视角，演绎自顶向下的PBE将一个综合问题解释为type inhabitance问题。这种解释在底层DSL是松散约束的情况下最为有效，即允许任意类型安全的子表达式组合。特别是，任何具有代数数据类型的类似ML的计算都可以作为类型驱动综合的核心语言。

类型理论对PBE的解释依赖于两个关键思想。首先，它将所需程序的示例、规范和约束视为类型细化***type refinements***。细化类型理论研究由可决定逻辑中谓词修饰的类型。

第二，细化类型理论发展了解决***type inhabitance***问题的程序——找到具有给定类型的项(可以同构地视为细化类型检查)。这是一个在文献中被充分研究的问题，自然演绎是最常见的方法。更普遍的是，所有类型检查/存在的方法都表现出类似于自顶向下搜索的特性:它们将对表达式的细化推到其子表达式，并使用子表达式的类型检查结果来推断兄弟项的新的细化。由于类型不良的术语远远多于类型良好的术语，并且局部推理过程消除了类型不良的候选项，因此检查类型存在对于充分表达的细化是非常有效的。

## 7.4 Ambiguity Resolution

示例本质上是一个不规范的，即在一个丰富的假设空间中可能有多个可能的程序，这些程序与给定的一组示例是一致的。只要给出足够的例子，就可以对规范进行细化，使所需的程序保持一致。但是在许多真实的环境中，期望用户提供大量的示例是不现实的，并且**PBE系统的可用性通常以理解用户意图所需的示例数量最少为特征**。学习所需程序所需的输入-输出示例的数量或代表性是基础DSL的函数，也曾被称为DSL的teaching dimension。随着DSL的表达能力的提高(允许用户执行更丰富的任务)，区分DSL中的程序所需的代表性示例的数量也在增加。我们现在讨论两种技术，以使用很少的输入-输出示例(**通常只有一个输入-输出示例**)在富DSL中学习程序。

### 7.4.1 Ranking

排名的主要思想是给一组程序中的每个程序分配一个可能性分数，这组程序是由一小组输入-输出示例归纳而成的，因此得分最高的程序对应于用户期望的程序。在程序合成中有许多以前的方法，这些排序函数都是手动定义的。设计一个好的排名功能需要大量的领域专业知识和洞察力，这通常是一个耗时且容易出错的过程。此外，这些排序函数对于DSL或基准测试问题的变化本身并不健壮，因为可能的排序函数的空间相当大，并且很难手动分析每个可能的函数。Singh和Gulwani提出了一种基于机器学习的技术，从训练数据中自动学习PBE系统的排序函数(超过语法程序特征)。Ellis和Gulwani提出了另一种基于机器学习的技术来学习排序函数，该函数依赖于**独立于程序结构的特征**，而不是依赖于对程序行为的习得偏差，对程序执行轨迹更普遍。自动学习这些排名函数有三个关键挑战。首先，需要大量的标记训练数据。第二，需要适当的机器学习技术和相应的成本函数来优化。最后，排名函数应该允许高效地识别排名最高的程序，而不必枚举诱导程序集中的每个程序。

基于机器学习的排名技术被应用到FlashFill PBE系统中，与之前手动设计的排名功能相比有了显著的改进。FlashFill使用由联合节点、连接节点和显式枚举节点组成的VSA构造一组与给定的输入-输出示例一致的程序。根据VSA中每一种节点的单个排名函数，相应地以分层的方式定义排名函数。排名函数首先递归地计算DAG中每个单独节点的顶级表达式，然后使用与Dijsktra的最短路径算法类似的算法组合它们，以找到DSL中排名最高的顶级表达式。分级排序函数允许在不枚举的情况下(即不打破基于VSA的共享)有效地识别排名最高的程序。

对程序进行排序的想法是受到在信息检索中学习排序技术的启发。这些技术通常旨在将所有相关文档排在所有非相关文档之上，或者将最相关的文档排在最高的位置。然而，在程序合成中，这已经足够将任何正确的程序排列得比所有错误的程序都高。这是用于优化成本函数设计的关键洞见。

这些程序用下面的定义分别标记为**正程序和负程序**：

![image-20210522211254964](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20210522211254964.png)

换句话说，如果一个程序与所有的输入-输出例子一致，那么它就被标记为正程序。否则，它就被贴上了负程序的标签。

详细Ranking算法可见论文***Predicting a Correct Program in Programming by Example***

### 7.4.2 Active Learning

减少歧义的另一种方法是使用主动学习方法要求用户提供最少的额外输入-输出示例。Jha等人提出了在程序合成中合成区分输入来消除歧义的思想，我们在§3.2.1中介绍了这一思想。传统的合成方法学习与一组输入-输出例子{(i*k*, o*k*)}*k*相一致的程序P。**基于主动学习的想法是合成两个程序P1和P2,和一个输入i, 这样两个程序输入-输出例子集合上相一致, 例如 P1 (i*k*) = P2 (i*k*) =o*k*,但是它们在输出*i*上产生不同的输出, 例如P1(*i*) != P2(*i*)。然后系统可以要求用户在输入i上提供所需的输出，以进一步指导合成过程。**

区分输入是主动学习的一种形式——从用户那里征求额外的反馈，以启动新一轮的学习。文献中探讨的其他PBE用户交互模型包括:

- 向用户显示程序。通过让她分析程序的行为，这可能会简化发现差异的过程。
- 用自然语言解释程序。这是前一个选项的变体，更适合非程序员。
- 接受否定的例子，指出一个差异，但不提供正确的输出。如果手动计算所需的输出过于繁琐，那么这就简化了交互。

Mayer等人使用FlashProg系统(也在§3.2.1中描述)通过实例比较了文本抽取领域的这些交互模型。他们发现，与其他模型相比，消除歧义问题有助于实现更高的正确率和更快的任务完成时间。比较产生歧义消解问题的不同策略，可能会减轻用户不必要的认知负担，是未来的研究课题。目前，在主动学习过程中尽量减少澄清问题的次数是一个有待研究的问题。如前所述，学习给定概念所需的最少问题数被称为DSL的教学维度***teaching dimension***。不仅找到最优教学序列一般来说是NP-hard，而且在程序合成中使用的大多数非平凡语言还没有被计算或限定。尽管缺乏最优保证，基于主动学习的方法倾向于快速收敛到正确的解决方案，例如，在smt引导的位向量程序学习中，平均有7个例子。

