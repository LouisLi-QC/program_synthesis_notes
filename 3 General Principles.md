# 3 General Principles

![General Principles of Program ](C:\Users\lenovo\Desktop\NTU暑研\Progress Report\General Principles of Program .png)

## 3.1 Second-order Problem Reduction

##### 基本思想：

Program synthesis是一个二阶搜索问题，一般来说是一个无法确定的问题。如果我们能把这个二阶化简化对于一阶搜索问题，我们可以利用现成的约束求解器来处理一阶约束。实现这一点的方法是通过使用模板。

基于模板的程序合成方法建立在基于模板的程序验证方法的基础上。后者试图找到一个归纳证明的正确性，给出一个程序和前/后条件对。

模板非常类似于§3.3.1中所讨论的Sketch系统中的草图（梗概）。然而，有两个关键的区别。Sketch合成每个（孔？）有边界的整数，而程序模板包含任意表达式和谓词的孔，因此合成器需要生成潜在的无界值。其次，Sketch只有部分程序的概念，并且只确保有边界的验证，而模板与底层基于模板的完全验证方法很好地匹配，该方法也允许部分不变量的描述。

##### 读后问题：

大概意思应该是说有了模板事情就好办了

具体什么是一阶问题/二阶问题？

现成的约束求解器有什么？

## 3.2 Oracle-Guided Synthesis

##### 基本思想：

在大多数情况下，相关的特定于域的模板是不可用的。对于这种情况，社区采用了另一种简单的方案合成方法。它基于以下观察：当合成一个满足给定性质的程序是一个可能不可行的二阶问题时，验证一个给定的程序是否满足该性质是一个一阶问题，通常更直接。

**例子：**

对找到list L 中的最大值 m 的描述取反，得到一个一阶问题。这就是**反例引导归纳合成(CEGIS)的架构**

**反例引导归纳合成(CEGIS)的架构**：在CEGIS中，我们将综合问题分为搜索和验证。第一个组件(通常称为求解器)从一个简单的一阶规范开始，这是所需程序的原始二阶要求的简化版本。它产生一个满足这个简化规范的候选程序。第二个组件(通常称为校验器)验证该候选程序是否满足原始规范。**如果没有，验证器将产生一个反例，该反例将返回给求解器。求解器将这个反例添加到规范中，并重复它的搜索，寻找一个新的候选程序**，另外，满足这个反例。这个过程重复迭代,直到：

(a) 验证人接受一些项目的候选程序——也就是说,我们发现了一个程序,满足整个二阶规范；

或(b) 解算器无法找到一个候选程序与当前的规范一致——也就是说,最初的问题是无法解决的。

##### 读后问题：

我理解的是，CEGIS通过不断反馈反例的情况来突出需求中没有被满足的部分，达到合成一个符合相关性质程序的目的。

### 3.2.1 Distinguishing Iuputs  突出输入

##### 基本思想：

突出输入任务：目标是从满足给定规范的基本组件库中自动合成无循环程序。该方法适用于本文研究的多个领域，包括位向量操作和函数解混淆。

问题定义假设存在一个完整但昂贵（？）的验证oracle。它将一个候选程序P作为输入，并验证它是否满足规范。根据领域和规范的不同，编写这样的oracle可能是一项具有挑战性的任务。例如，如果规范是由另一个不合格的实现 Pφ 给出的，我们可以在 P 和 Pφ 上运行程序等价工具，以检测它们是否在所有可能的输入上表现相同。然而，一般情况下，程序等价性是无法确定的。一般来说，对于大多数域和规范来说，最好的验证oracle往往是用户，他们可以手动检查候选程序P。显然，这种方法阻止我们在合成过程中经常并以灵活的方式自动地查询和验证oracle。

为了避免查询验证oracle, Jha等人**根据具体输入上的程序可区分性（分辨率）**重新表述了这个问题。
它们不需要验证oracle，而是需要能够在任意给定输入上生成有效程序输出的I/O oracle。然后他们用这些关键的观察结果来减少问题:

观察项目1告诉我们，与有限数量的有效输入/输出对相一致的程序是与整个规范 φ 相一致的程序的一个很好的候选。观察项目2告诉我们，如果一个不正确的候选程序 P 恰好与所选的输入集一致，那么可以通过用一个新的特别输入，扩展该输入集，来检测它。该输入为当前候选程序 P 和一些其他可能的候选程序P∗产生不同的行为(仍然与以前的输入一致)。如果这种输入不存在，那么所有与所选输入集一致的程序在语义上是等价的——它们在所有输入上产生相同的输出。因此，要么任何这样的候选者都是正确的(可以通过对验证oracle的单个调用进行验证)，要么不能从给定的组件构造正确的程序。

**算法：**function **CBSynthesis**

**结果**表明，对于位向量域，<u>即使随机选择有突出输入</u>，这个过程在最多25步内收敛到一个语义唯一的程序。更一般地说，迭代的次数取决于所选择的突出输入。他们或多或少地<u>为程序分割搜索空间</u>，这取决于不同的运算符在这些输入上产生的碰撞次数。这个属性在许多设置中出现；例如，用随机抽样替换SMT求解器以更快地发现可区分的输入。在位向量域中，大多数常见的运算符更受输入的最右位的影响。这表明，偏重于最右边位的更多变化的采样输入应该更快地发现不同的输入，Jha等人通过实验证实了这一点‘

##### 读后问题：

应该翻译成突出输入比较好，意思是通过一些特殊的突出iuputs来判断候选集的错误

问题在于，这个突出的iuput是咋个选出来的呢？如果只是随机选那不就是单纯去扩充输入的数量吗？“sampling inputs with a bias for more variety in rightmost bits should discover distinguishing inputs faster” **rightmost bits **是啥意思？

还要看关于distinguishing iuput的论文：[Oracle-Guided Component-Based Program Synthesis](http://people.eecs.berkeley.edu/~sseshia/pubdir/icse10-TR.pdf)

#### End-user confidence:

##### 基本思想：

Distinguishing iuputs 突出输入可以作为与用户沟通的媒介。考虑一个向用户公开的程序合成系统，用户迭代地引入对合成任务的约束。在每一轮中，系统向用户提供一个候选程序，该程序满足迄今为止积累的约束条件。最终，用户在这里充当一个验证oracle：<u>她需要确定当前程序何时满足了她的总体意图，而不需要添加更多约束来合成一个更好的程序。</u>然而，在某些情况下，这种验证对用户来说可能很麻烦，甚至是不可能的。在这种情况下，系统可以通过交互式反馈帮助她，提出方法来验证当前的候选程序是明确的。区分输入就是一种可能的反馈。

**例子：**

例如根据PBE的FlashProg，这个系统自动检测候选程序和代替者们的输出差异，这个输出的对应输入就是一个distinguishing iuput。通过询问用户来找到错误。

##### 读后问题：

我感觉这就是在生成测试用例，这边问一下用户好做监督学习哈哈

## 3.3 Syntactic Bias  语法偏差

程序合成需要语法性地减少可能的程序空间，语法偏差有很多，比如局部程序草图、语法或领域特定语言（DSL）

### 3.3.1 Sketching  草图/梗概

##### 基本思想：

Sketch system: 程序员通过sketch提供见解，表示了预期实现的高级结构，但为低级实现细节留下了空缺。**Sketch合成器从有限的选择集合中填补这些空缺，这样完整的程序就可以使用CEGIS算法满足所提供的规范。**使用sketch的主要思想是让程序员能够轻松地进行合成，因为他们可以使用他们已经知道的编程模型形式体系提供深刻的见解，而不需要学习其他形式体系，如规范语言或定理证明。

The Sketch synthesizer fills up these holes for low-level implementation details from a finite set of choices such that the completed program satisfies the provided specification using the CEGIS algorithm

**例子：**

sketch中有丰富的表达式，可以利用未知的integers来指定一个假设空间；使用generator function，递归并简洁地定义大空间的表达式（利用holes）

### 3.3.2 Syntax-Guided Synthesis  语法引导合成

##### 基本思想：

语法引导的合成是最近社区致力于标准化程序合成问题的一项努力，其中逻辑规范被用户提供的语法模板补充，以约束可能的程序的假设空间。语法引导合成问题(SyGuS)的输入由一个定义了词汇和函数以及关系符号的<u>背景理论T</u>，一个对于给出程序的语义正确性规范的<u>逻辑公式φ</u>，由<u>上下文无关语法G</u> .给出的候选实现的语法集。然后，计算问题是从候选实现集(即语法G中的一个派生)中找到一个实现，使该实现满足给定理论T中的规范φ。

**影响：**

SyGuS的努力导致社区努力从各种合成领域收集基准测试到一种公共格式。还催生了SyGuS-Comp，这是一项一年一度的综合竞赛，让求解者可以在一系列基准测试上竞争。

##### 读后问题：

意思是对于输入更加标准了么？不是很懂SyGuS的具体实现方式，书上的例子没看懂

### 3.3.3 DSL Design  领域专用语言设计

##### 基本思想：

DSL：领域专家用双方都能理解的自然语言来解释。这种解释的过程中，解决方案的模型构建者就理解了领域知识。这个过程中双方使用的语言就被称为“共同语言”。

**领域专用语言 DSL 的选择受到几个因素的启发：**

**Balanced Expressivity 平衡的表达性：**一方面，DSL应该具有足够的表达性，以表示底层任务域中的各种任务。另一方面，它应该受到足够的限制以允许有效的搜索。

**Choice of Operators 操作符的选择：**DSL应该由允许有效推理的操作符组成。例如，操作符应该有小的逆命题（？），以使自上而下的演绎搜索策略(§7.3)有效。

**Natualness 自然性：**DSL中的程序应该包含用户容易理解的自然计算模式。这可以增加用户对系统的信心。事实上，这些计算模式应该类似于程序员自己编写代码的方式。用户可以阅读这些程序，然后在这些程序之间进行选择、编辑，甚至将它们作为更大的工作流的一部分使用。

**Efficiency 效率：**DSL中的运算符应该有高效的实现。如果期望合成的程序在大量输入的紧密循环中运行，这一点很重要。

设计一个好的DSL通常是开发一个好的程序合成器的第一个重要想法。来自数据争夺领域的一些重要DSLs：**Flash Fill DSL, FlashExtract DSL, FlashRelate DSL**

## 3.4 Optimization

##### 基本思想：

程序合成问题的基本阐释是要求在给出的空间 L (例如DSL)中找到满足规格 φ 的任何程序 P 。然而，在许多情况下，我们感兴趣的不是*“任何”*程序，而是根据某些**代价函数**的*“最佳”*程序。这就是所谓的合成排序或优化。实践中出现的一些有趣的**代价函数**有:

**Program speed 程序速度：**这是超优化的默认选择(§2.6)。

**Robustness 鲁棒性：** 这是数据争论(§2.1)的示例编程PBE(第7章)的默认设置，程序是在一小部分输入数据上学习的，但它应该适用于其他尚未看到的用户数据。换句话说，学习<u>不应该过度拟合</u>提供的输入-输出例子。

**“Naturalness” or “readability” “自然”或“可读性”：**这是一个程序是否为开发人员所接受的度量。例如，该代价函数可以考虑底层语言中的常见习惯用法。可以通过从源代码的语料库中挖掘习语，或者通过将排名委托给搜索引擎，来明确地利用习语的概念。

**总结：**优化的目的无非是  速度、鲁棒性、可读性

**Markov Chain Monte Carlo MCMC techniques**

MCMC 采用了一种遗传规划的变体，其中Metropolis-Hastings算法用于探索可能的程序的搜索空间。在MCMC抽样中，我们的目标是从空间中以与程序代价成比例的概率绘制程序。<u>在极限条件下，最频繁抽样的程序将是代价函数上的全局最优；在实践中，运行MCMC抽样过程一段合理的时间后通常会发现一个“足够好的”局部最优。</u>从某种意义上说，Metropolis-Hastings算法可以被视为一种“智能”<u>爬山算法</u>，它能够适应局部最优，而且只受时间预算的限制。

**Version Space Algebras**

版本空间代数(VSAs)提供了程序空间的简洁表示，符合基于结构的排序。假设代价函数为单调函数h(P)，在VSA结构中寻找最顶层程序的问题可以通过 beam search 来解决，该结构从它的子表达式自下而上构造所需的程序。

**Machine Learning**

机器学习方法被广泛用于程序合成和优化。他们的应用包括自动学习代价函数，处理规范中的噪声，甚至端到端程序合成。我们在§6.3和7.4.1中描述了其中一些应用。

**Metasketches**

Metasketches 是 sketch 的概括(§3.3.1)。它不是一个单一的部分程序，它给出了一个有序的部分程序家族，连同一个代价函数和一个梯度，这表明在家族中哪些 sketches 可能包含一个成本较低的程序。换句话说，它将搜索空间描述为一组可以独立探索的有限子空间，并提供指导功能以经济有效的方式导航这些子空间。利用这一公式，Bornholt等人提出了一种最优综合算法，该算法使用CEGIS独立并行地探索多个局部子空间，并使用一个单独的全局组件协调他们的发现，以引导搜索到更多的最优方案。

##### 读后问题：

这些代价函数的应用我需要再深入阅读才能理解得更好。

我觉得可以先看下 ML 是怎么优化的
